using System.Collections;
using System.Collections.Generic;
using UnityEngine;


/// <summary><c>BuildDecorator</c> is a class that contains various utility methods to generate more complex buildings, mainly small decorations.
/// The methods in this class are all static, and add lille gizmos to given combineInstances Lists, such as antenas, doors, windows, plants...
/// Meshes generated by this decorator may be slightly random, but are assumed to not be of core importance and do not use seeds to create assets.</summary>
public static class BuildDecorator
{
    public static readonly float UniversalFloorSize = BuildingComposer.UniversalFloorSize;

    public static void addBrutalSegment(List<CombineInstance> combine, float x, float z, float sizeX, float sizeZ, int floors)
    {
        Mesh cube = PrimitiveFactory.GetMesh(PrimitiveType.Cube);
        Mesh pyra = PrimitiveFactory.GetMesh(PrimitiveType.Pyramid4);
        float height = UniversalFloorSize * floors;
        combine.Add(new CombineInstance
        {
            mesh = cube,
            subMeshIndex = 0,
            transform = Matrix4x4.TRS(new Vector3(x + (sizeX / 2), 0.01f + height / 2, z + (sizeZ / 2)), Quaternion.identity, new Vector3(sizeX, height, sizeZ))
        });
        for (int f = 1; f <= floors; f++)
        {
            combine.Add(new CombineInstance
            {
                mesh = cube,
                subMeshIndex = 0,
                transform = Matrix4x4.TRS(new Vector3(x + (sizeX / 2), 0.01f + (f * height / floors), z + (sizeZ / 2)), Quaternion.identity, new Vector3(sizeX + 0.2f, 0.1f, sizeZ + 0.2f))
            });
        }
        combine.Add(new CombineInstance
        {
            mesh = pyra,
            subMeshIndex = 0,
            transform = Matrix4x4.TRS(new Vector3(x + (sizeX / 2), 0.51f + height, z + (sizeZ / 2)), Quaternion.identity, new Vector3(sizeX, 1, sizeZ))
        });

    }

    public static void AddAntenasCluster(List<CombineInstance> combine, float x, float y, float z, float sizeX, float sizeZ) {
        AddAntenasCluster(combine,x,y,z,sizeX, sizeZ,15);
    }

    public static void AddAntenasCluster(List<CombineInstance> combine, float x, float y, float z, float sizeX, float sizeZ, int amount)
    {
        Mesh cube = PrimitiveFactory.GetMesh(PrimitiveType.Cube);
        Mesh rod = PrimitiveFactory.GetMesh(PrimitiveType.TriPrism);
        Mesh sphere = PrimitiveFactory.GetMesh(PrimitiveType.Isocaedron);
        combine.Add(new CombineInstance
        {
            mesh = cube,
            subMeshIndex = 0,
            transform = Matrix4x4.TRS(new Vector3(x + (sizeX / 2), y + 0.015f, z + (sizeZ / 2)), Quaternion.identity, new Vector3(sizeX, 0.03f, sizeZ))
        });

        for (int i = 0; i < amount; ++i)
        {
            bool big = Random.Range(0f, 1f) > 0.9f;
            float antenaheight = Random.Range(0.4f, 1.5f), antenaPosX = Random.Range(0f, sizeX), antenaPosZ = Random.Range(0f, sizeZ);
            if (big)
            {
                antenaheight = antenaheight * 2 + 2;
                combine.Add(new CombineInstance
                {
                    mesh = sphere,
                    subMeshIndex = 0,
                    transform = Matrix4x4.TRS(new Vector3(x + antenaPosX, y +  antenaheight, z + antenaPosZ), Quaternion.identity, new Vector3(0.2f, 0.2f, 0.2f))
                });
            }
            combine.Add(new CombineInstance
            {
                mesh = rod,
                subMeshIndex = 0,
                transform = Matrix4x4.TRS(new Vector3(x + antenaPosX, y + 0.005f + antenaheight / 2, z + antenaPosZ), Quaternion.identity, new Vector3(0.1f, antenaheight, 0.1f))
            });
        }

    }

}
